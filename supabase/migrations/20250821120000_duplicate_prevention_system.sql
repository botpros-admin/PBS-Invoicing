-- Step 1: Create Audit Trail Table
-- This table logs all "push through" overrides for duplicates.
CREATE TABLE public.audit_trail (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    user_id UUID REFERENCES auth.users(id),
    action VARCHAR(255) NOT NULL,
    entity_type VARCHAR(255) NOT NULL,
    entity_id UUID,
    details JSONB,
    reason TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.audit_trail IS 'Logs significant user actions, especially for auditing overrides like duplicate invoice items.';
COMMENT ON COLUMN public.audit_trail.reason IS 'Justification provided by the user for performing the action.';

-- Enable RLS
ALTER TABLE public.audit_trail ENABLE ROW LEVEL SECURITY;
-- Policies will need to be created based on specific application roles.


-- Step 2: Create Duplicate Review Queue Table
-- This table will store invoice items that are flagged as duplicates for manual review.
CREATE TABLE public.duplicate_review_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    organization_id UUID NOT NULL REFERENCES public.organizations(id) ON DELETE CASCADE,
    accession_number TEXT NOT NULL,
    cpt_code VARCHAR(20) NOT NULL,
    service_date DATE NOT NULL,
    unit_price NUMERIC(10, 2) NOT NULL,
    quantity INT NOT NULL DEFAULT 1,
    patient_name TEXT,
    raw_import_data JSONB,
    status VARCHAR(50) NOT NULL DEFAULT 'pending', -- e.g., pending, approved, rejected
    notes TEXT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    reviewed_by UUID REFERENCES auth.users(id),
    reviewed_at TIMESTAMPTZ
);

COMMENT ON TABLE public.duplicate_review_queue IS 'Stores potential duplicate invoice items for manual review and approval/rejection.';
COMMENT ON COLUMN public.duplicate_review_queue.raw_import_data IS 'The original row data from the imported file.';

-- Add indexes for faster queries
CREATE INDEX idx_duplicate_review_queue_organization_status ON public.duplicate_review_queue(organization_id, status);

-- Enable RLS
ALTER TABLE public.duplicate_review_queue ENABLE ROW LEVEL SECURITY;


-- Step 3: Modify invoice_items table
-- Make cpt_code non-nullable to enforce the unique constraint.
-- This assumes that all existing rows have a valid cpt_code.
-- If not, a data migration script would be needed to populate missing codes.
ALTER TABLE public.invoice_items
ALTER COLUMN cpt_code SET NOT NULL;


-- Step 4: Create the new unique constraint
-- This is the core of the duplicate prevention at the database level.
-- We are dropping the old constraint and adding the new, more precise one.
ALTER TABLE public.invoice_items
DROP CONSTRAINT "invoice_items_organization_id_accession_number_cpt_code_id_key";

ALTER TABLE public.invoice_items
ADD CONSTRAINT "uniq_org_accession_cpt_code"
UNIQUE (organization_id, accession_number, cpt_code);

